> 这些知识，懒得分类记载吧，因为太琐碎了


### 什么是 *前端路由* ？什么时候适合使用 *前端路由*？*前端路由* 有哪些优点和缺点?


 - **什么是路由：** 前端路由其实就是根据请求不同的url，展示不同的页面及内容

 - **路由适用在哪里：**一般适合在一部分数据不变，一部分数据变的网页中使用前端路由
 
 - **前端路由优点：** 在以前，都是使用后端路由，由后端渲染页面，使得用户每次在请求不同url的时候，都会刷新页面，这样会造成非常不好的用户体验。而使用前端路由，再适当的结合ajax，可以使得用户在请求不同的url的时候，实现页面无刷新的效果，不会出现使用后端路由那种遇到网络延迟出现短时间的空白情况，并且大大的减少服务器的压力。

 - **前端路由缺点：**当点击浏览器中的前进，后退按钮，同样会再次发送无用请求，并不能很好的利用缓存数据



### 怎么理解node中的异步和同步

>`node` 中的模块支持的是 `commonJS` 的规范，也就是在每次引入模块的时候，是同步的，但由于 `node` 是js编写的，属于事件驱动型语言。而事件驱动主要在于异步回调，这样可以更高效的利用系统资源



### 三个使用this的典型应用

**1. **正常的使用函数，当给一个元素绑定事件，函数内不想或者不方便再次获取该元素的时候，就可以使用this

**2. **循环注册事件的时候，虽然事件是异步的，但是this关键词还是每次指向注册事件的那个元素

**3. **作用构造函数调用


### 垃圾回收机制方式及内存管理

>说到垃圾回收机制，就不得不说下变量的生命周期，全局变量的生命周期是从开始生命创建，到关闭页面，持续事件特别久，这样特别消化内存，所以尽量少声明全局变量。

> 而js的垃圾回收方式，无外乎，**标记清除**，也就是当变量进入到执行环境中的时候，js的垃圾回收器就会将其做个标记，等到该函数执行完之后，该变量就会被回收，这也就是所说的，函数中的变量生命周期只存在于执行函数开始到执行函数结束。

> 还有一种就是 **引用计数** ，其实就是js内部会跟踪每一个变量每一个值，当变量或者该值没有被引用的时候，就会被回收内存，而这种常常会引起内存泄露问题。

> 所以，我们平时写代码的时候，尽量少声明全局变量，并且当一个变量不使用的时候，要及时清空该变量


### 浅谈隐士迭代和链式编程的理解

> jQuery里的隐世迭代和链式编程的话，

> **隐世迭代**其实就是传递一个dom数组的话，jQuery会在内部遍历内部dom数组，并给其中每个dom元素对应的dom属性及方法，

> **链式编程**，其实就是jQuery内部传递一个对象，返回函数本身，这样就可以一直调用该对象上的方法，当然链式编程也不可能一直链式编程下去，当需要返回另外一个对象时，就会出现断链情况，这个时候只需要使用jQuery里的end()方法就可以恢复断链


## JS从定义到执行所经历的过程

![](https://i.imgur.com/0AHn4Pi.png)

#### 一、（执行前）执行前准备
  **1. 初始化变量** （也可以理解为浏览器在解析代码的时候，进行变量提升）

  **2. 创建一个全局对象Function**
	
   - 所以也就解释了为啥会说Function创建了所有对象

   - 它存在于应用程序的整个生命周期
	
   - 并且在创建全局对象的同时，将**Math,String,Date,document** 等常见的js对象作为该对象的属性
	
   - 另外，因为这个全局对象是个虚拟的，无法通过名字访问它，所以产生了一个另外一个属性 **Window** ，作为其代理。访问全局对象


  **3. 同时，js引擎会创建一个执行环境，同时，也会创建一个全局环境**
	
   - 这个全局环境也可以称之为全局作用域，而全局环境又处于这个执行环境栈中
	
   - 执行环境栈的作用 （**保证代码按照特定的顺序依次解析**)

 **4. 当执行函数的时候，该函数的执行环境会被堆到执行环境栈的顶部获得执行权，执行完毕之后，该函数的执行环境会从执行环境栈中删除**
	
   - 这也就可以解释之前为啥会说函数中的变量的生命周期只有在函数执行的时候才会存在

  **5. 最后会创建一个与全局对象想关联的全局变量对象Object,指向该全局对象**
	
   - 也可以理解为Function创造了Object ，该全局变量对象Object不仅包含全局对象所有的属性，还包含全局定义的变量跟函数

  **6. 在创建函数的时候，会同时为其配备一个内部属性scope(作用域)并且scope指向Object**
	
   - 每个函数定义的时候，都会创建一个与之关联的scope属性，该scope总是指向定义函数所存在的环境


####（执行）在执行函数 A 的时候
	
   **1. js会创建一个该函数的执行环境，并将其推到执行环境栈中获得执行权**
	
   **2. 此时执行环境栈中，有两个东西，一个是该函数的执行环境在栈顶，另外一个全局执行环境存在栈底**
     - 接着js会创建一个该函数的作用域链，用于标识符解析
 
   **3. 当执行环境被创建时，它的作用域链就初始化为当前运行函数的scope所包含的对象。**

     - 然后会创建该执行函数的活动对象（这里的活动对象充当着变量对象的角色）
 
  ** 4. 该活动对象包含了函数的形参，arguments对象，this对象以及局部变量和内部函数的定义**
  
   **5. 然后该活动对象会被推到作用域链的顶部（如果在该函数的内部定义了另外一个函数B的时候）**

  ** 6. 同样会为函数B创建一个scope属性，并将其指向函数B所在的环境内**
		
   **7. 函数B的环境就是函数A的活动对象**  【活动对象处于链表的顶端 ，该链表具有收尾相连的特性】
		
  ** 8. 函数B的scope属性会指向函数 A 的作用域链**


